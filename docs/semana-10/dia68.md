---
sidebar_position: 68
---

# D√≠a 68 - Documentaci√≥n que Realmente Se Usa

## üéØ Objetivo del D√≠a
Crear documentaci√≥n √∫til, simple y que el equipo realmente consulte

---

## üìã Plan de Documentaci√≥n Pr√°ctica

| ‚è∞ Tiempo | üìã Tarea | üéØ Resultado |
|----------|-----------|--------------|
| **30 min** | üìù README s√∫per claro | Documentaci√≥n que funciona |
| **40 min** | üöÄ Gu√≠as de despliegue simples | Deploy sin errores |
| **35 min** | üîß Manual de problemas comunes | Soluciones r√°pidas |
| **30 min** | üìä Dashboard de documentaci√≥n | Todo en un lugar |
| **15 min** | ‚úÖ Validar con el equipo | Confirmar que sirve |

---

## üìù Paso 1: README S√∫per Claro (30 min)

### 1.1 Template de README efectivo

```markdown
# üöÄ DevOps Challenge Project

> Sistema de monitoreo y despliegue automatizado

## ‚ö° Inicio R√°pido (5 minutos)

### Prerrequisitos
- Docker y Docker Compose
- Git
- 4GB RAM libre

### Instalaci√≥n
```bash
# 1. Clonar proyecto
git clone https://github.com/tu-usuario/devops-challenge.git
cd devops-challenge

# 2. Configurar entorno
cp .env.example .env
# Editar .env con tus valores

# 3. Levantar todo
docker-compose up -d

# 4. Verificar que funciona
curl http://localhost:3000
```

‚úÖ **Ya est√° funcionando!** Ve a http://localhost:3000

## üìã ¬øQu√© hace este proyecto?

- üîç **Monitoreo**: Grafana + Prometheus para m√©tricas
- üö® **Alertas**: Notificaciones autom√°ticas a Slack
- üöÄ **CI/CD**: Deploy autom√°tico con GitHub Actions
- üõ°Ô∏è **Seguridad**: Escaneo de vulnerabilidades autom√°tico
- üìä **Reportes**: Dashboards y reportes diarios

## üèóÔ∏è Arquitectura Simple

```
Internet ‚Üí Load Balancer ‚Üí App Servers ‚Üí Database
                    ‚Üì
              Monitoring Stack
              (Grafana + Prometheus)
```

## üöÄ Comandos √ötiles

### Desarrollo
```bash
# Ver logs en tiempo real
docker-compose logs -f

# Reiniciar un servicio
docker-compose restart app

# Ejecutar tests
make test

# Ver m√©tricas
curl http://localhost:9090/metrics
```

### Producci√≥n
```bash
# Deploy a producci√≥n
make deploy-prod

# Ver estado de servicios
make status

# Backup de datos
make backup

# Rollback si algo falla
make rollback
```

## üÜò Problemas Comunes

| Problema | Soluci√≥n |
|----------|----------|
| Port 3000 occupied | `docker-compose down && docker-compose up -d` |
| Database connection error | `docker-compose restart db` |
| High memory usage | `docker system prune -f` |
| Grafana not loading | Check `docker-compose logs grafana` |

## üìö Recursos Adicionales

- üèóÔ∏è **Arquitectura**: Ver el sistema completo en el dashboard generado
- üöÄ **Deploy**: Scripts incluidos en este d√≠a para deploy automatizado  
- üîß **Troubleshooting**: Base de conocimiento generada autom√°ticamente
- üìä **Monitoreo**: Dashboard HTML con todas las m√©tricas
- üõ°Ô∏è **Seguridad**: Gu√≠as integradas en la documentaci√≥n auto-generada

---

**üí° ¬øAlgo no funciona?** Revisa los logs con `docker-compose logs -f` o el dashboard HTML generado
```

### 1.2 Script para generar documentaci√≥n autom√°tica
```python
#!/usr/bin/env python3
# generate-docs.py - Generar documentaci√≥n autom√°ticamente

import os
import json
import subprocess
from datetime import datetime
from pathlib import Path

class DocumentationGenerator:
    def __init__(self):
        self.project_root = Path(".")
        self.docs_dir = Path("docs")
        self.docs_dir.mkdir(exist_ok=True)
    
    def generate_project_overview(self):
        """Generar overview del proyecto"""
        overview = {
            "name": self.get_project_name(),
            "description": self.get_project_description(),
            "version": self.get_project_version(),
            "services": self.get_docker_services(),
            "ports": self.get_exposed_ports(),
            "dependencies": self.get_dependencies()
        }
        
        with open(self.docs_dir / "project-overview.json", "w") as f:
            json.dump(overview, f, indent=2)
        
        return overview
    
    def get_project_name(self):
        """Obtener nombre del proyecto"""
        if Path("package.json").exists():
            try:
                with open("package.json") as f:
                    return json.load(f).get("name", "devops-project")
            except:
                pass
        
        return Path.cwd().name
    
    def get_project_description(self):
        """Obtener descripci√≥n del proyecto"""
        if Path("package.json").exists():
            try:
                with open("package.json") as f:
                    return json.load(f).get("description", "DevOps Challenge Project")
            except:
                pass
        
        return "Sistema de monitoreo y despliegue automatizado"
    
    def get_project_version(self):
        """Obtener versi√≥n del proyecto"""
        try:
            result = subprocess.run(["git", "describe", "--tags", "--abbrev=0"], 
                                  capture_output=True, text=True)
            if result.returncode == 0:
                return result.stdout.strip()
        except:
            pass
        
        return "1.0.0"
    
    def get_docker_services(self):
        """Obtener servicios de Docker Compose"""
        if not Path("docker-compose.yml").exists():
            return []
        
        try:
            result = subprocess.run(["docker-compose", "config", "--services"], 
                                  capture_output=True, text=True)
            if result.returncode == 0:
                return result.stdout.strip().split('\n')
        except:
            pass
        
        return []
    
    def get_exposed_ports(self):
        """Obtener puertos expuestos"""
        ports = []
        
        if Path("docker-compose.yml").exists():
            try:
                with open("docker-compose.yml") as f:
                    content = f.read()
                    # Buscar patrones de puertos (simplificado)
                    import re
                    port_matches = re.findall(r'"(\d+):\d+"', content)
                    ports.extend(port_matches)
            except:
                pass
        
        return list(set(ports))
    
    def get_dependencies(self):
        """Obtener dependencias del proyecto"""
        deps = {}
        
        # Node.js dependencies
        if Path("package.json").exists():
            try:
                with open("package.json") as f:
                    data = json.load(f)
                    deps["node"] = list(data.get("dependencies", {}).keys())[:10]
            except:
                pass
        
        # Python dependencies
        if Path("requirements.txt").exists():
            try:
                with open("requirements.txt") as f:
                    deps["python"] = [line.strip().split('==')[0] 
                                    for line in f if line.strip() and not line.startswith('#')][:10]
            except:
                pass
        
        return deps
    
    def generate_api_docs(self):
        """Generar documentaci√≥n de API si existe"""
        api_docs = {
            "endpoints": [],
            "authentication": "Bearer token",
            "base_url": "http://localhost:3000/api"
        }
        
        # Buscar definiciones de rutas (muy simplificado)
        api_files = list(Path(".").glob("**/*api*")) + list(Path(".").glob("**/*route*"))
        
        for file_path in api_files[:5]:  # Limitar a 5 archivos
            if file_path.suffix in ['.js', '.py', '.ts']:
                try:
                    with open(file_path) as f:
                        content = f.read()
                        # Buscar patrones b√°sicos de endpoints
                        import re
                        endpoints = re.findall(r'@app\.route\(["\']([^"\']+)["\']', content)
                        endpoints += re.findall(r'app\.(get|post|put|delete)\(["\']([^"\']+)["\']', content)
                        
                        for endpoint in endpoints:
                            if isinstance(endpoint, tuple):
                                method, path = endpoint
                                api_docs["endpoints"].append({"method": method.upper(), "path": path})
                            else:
                                api_docs["endpoints"].append({"method": "GET", "path": endpoint})
                        
                except:
                    continue
        
        if api_docs["endpoints"]:
            with open(self.docs_dir / "api-reference.json", "w") as f:
                json.dump(api_docs, f, indent=2)
        
        return api_docs
    
    def generate_deployment_guide(self):
        """Generar gu√≠a de despliegue"""
        
        deployment_guide = "# Gu√≠a de Despliegue\n\n"
        deployment_guide += "## Despliegue Local\n"
        deployment_guide += "1. git clone <repository-url>\n"
        deployment_guide += "2. docker-compose up -d\n"
        deployment_guide += "3. curl http://localhost:3000/health\n\n"
        deployment_guide += "## Despliegue en Producci√≥n\n"
        deployment_guide += "1. Conectar SSH a servidor\n"
        deployment_guide += "2. Instalar Docker y Docker Compose\n"
        deployment_guide += "3. Clonar repo y configurar .env\n"
        deployment_guide += "4. docker-compose -f docker-compose.prod.yml up -d\n"

        with open(self.docs_dir / "deployment.md", "w") as f:
            f.write(deployment_guide)
        
        return deployment_guide
    
    def generate_troubleshooting_guide(self):
        """Generar gu√≠a de troubleshooting"""
        
        troubleshooting = "# Gu√≠a de Troubleshooting\n\n"
        troubleshooting += "## Docker Issues\n"
        troubleshooting += "- Container no inicia: docker-compose logs [service]\n"
        troubleshooting += "- Puerto ocupado: netstat -tulpn | grep :3000\n"
        troubleshooting += "- Sin espacio: docker system prune -f\n\n"
        troubleshooting += "## Database Issues\n"
        troubleshooting += "- Connection refused: docker-compose restart db\n"
        troubleshooting += "- Queries lentas: verificar indices\n\n"
        troubleshooting += "## Application Issues\n"
        troubleshooting += "- App no responde: verificar logs y recursos\n"
        troubleshooting += "- Memory leaks: reiniciar containers\n"
        
        with open(self.docs_dir / "troubleshooting.md", "w") as f:
            f.write(troubleshooting)
        
        return troubleshooting
        
        with open(self.docs_dir / "troubleshooting.md", "w") as f:
            f.write(troubleshooting)
        
        return troubleshooting
    
    def generate_docs_dashboard(self):
        """Generar dashboard HTML para documentaci√≥n"""
        
        overview = self.generate_project_overview()
        
        # Crear HTML simple para dashboard
        html_content = f"""
        <h1>Documentation Dashboard</h1>
        <p>Project: {overview['name']}</p>
        <p>Version: {overview['version']}</p>
        <div>Services: {len(overview['services'])} containers</div>
        """
        
        with open(self.docs_dir / "index.html", "w") as f:
            f.write(f"""
<!DOCTYPE html>
<html>
<head><title>Documentation</title></head>
<body>{html_content}</body>
</html>
""")
        
        return "index.html"
    
    def generate_all_docs(self):
        """Generar toda la documentaci√≥n"""
        print("üìö GENERANDO DOCUMENTACI√ìN COMPLETA")
        print("=" * 40)
        
        # Generar cada secci√≥n
        print("üìä Generando overview del proyecto...")
        overview = self.generate_project_overview()
        
        print("üîå Generando documentaci√≥n de API...")
        api_docs = self.generate_api_docs()
        
        print("üöÄ Generando gu√≠a de despliegue...")
        deployment = self.generate_deployment_guide()
        
        print("üîß Generando gu√≠a de troubleshooting...")
        troubleshooting = self.generate_troubleshooting_guide()
        
        print("üìä Generando dashboard de documentaci√≥n...")
        dashboard = self.generate_docs_dashboard()
        
        print(f"\n‚úÖ Documentaci√≥n generada en: {self.docs_dir.absolute()}")
        print(f"üåê Abrir dashboard: file://{self.docs_dir.absolute()}/index.html")
        
        return {
            "overview": overview,
            "api_docs": api_docs,
            "deployment_guide": "deployment.md",
            "troubleshooting_guide": "troubleshooting.md",
            "dashboard": dashboard
        }

if __name__ == "__main__":
    generator = DocumentationGenerator()
    result = generator.generate_all_docs()
    
    print("\nüìã ARCHIVOS GENERADOS:")
    for doc_type, filename in result.items():
        if isinstance(filename, str):
            print(f"   ‚Ä¢ {doc_type}: {filename}")
        else:
            print(f"   ‚Ä¢ {doc_type}: datos generados")
```

---

## üöÄ Paso 2: Gu√≠as de Despliegue Simples (40 min)

### 2.1 Ejecutar generador de documentaci√≥n
```bash
# Crear y ejecutar generador
python3 generate-docs.py

# Ver documentaci√≥n generada
ls -la docs/

# Abrir dashboard en navegador
open docs/index.html  # macOS
# xdg-open docs/index.html  # Linux
```

### 2.2 Gu√≠a de deploy de 1 comando
```bash
#!/bin/bash
# deploy.sh - Deploy en 1 comando

echo "üöÄ DEPLOYING APPLICATION..."
echo "========================="

# Verificar prerrequisitos
if ! command -v docker >/dev/null 2>&1; then
    echo "‚ùå Docker no est√° instalado"
    exit 1
fi

if ! command -v docker-compose >/dev/null 2>&1; then
    echo "‚ùå Docker Compose no est√° instalado"
    exit 1
fi

# Configurar entorno si no existe
if [ ! -f ".env" ]; then
    echo "üìù Creando .env desde template..."
    cp .env.example .env
    echo "‚ö†Ô∏è  Edita .env antes de continuar"
    echo "üí° Presiona Enter cuando est√© listo..."
    read -r
fi

# Build y deploy
echo "üî® Building containers..."
docker-compose build

echo "üöÄ Starting services..."
docker-compose up -d

echo "‚è≥ Esperando que servicios inicien..."
sleep 30

echo "üîç Verificando servicios..."
docker-compose ps

echo "üåê Testing endpoints..."
if curl -s http://localhost:3000/health > /dev/null; then
    echo "‚úÖ App principal: OK"
else
    echo "‚ùå App principal: FAIL"
fi

if curl -s http://localhost:9090 > /dev/null; then
    echo "‚úÖ Prometheus: OK"
else
    echo "‚ùå Prometheus: FAIL"
fi

if curl -s http://localhost:3001 > /dev/null; then
    echo "‚úÖ Grafana: OK"
else
    echo "‚ùå Grafana: FAIL"
fi

echo
echo "üéâ Deploy completado!"
echo "üìä Dashboard: http://localhost:3001"
echo "üìà M√©tricas: http://localhost:9090"
echo "üöÄ App: http://localhost:3000"
echo
echo "üí° Ver logs: docker-compose logs -f"
echo "üîß Troubleshooting: cat docs/troubleshooting.md"
```

---

## üîß Paso 3: Manual de Problemas Comunes (35 min)

### 3.1 Base de conocimiento autom√°tica
```python
#!/usr/bin/env python3
# knowledge-base.py - Base de conocimiento de problemas

import json
import re
from datetime import datetime
from pathlib import Path

class KnowledgeBase:
    def __init__(self):
        self.kb_file = Path("knowledge-base.json")
        self.problems = self.load_knowledge_base()
    
    def load_knowledge_base(self):
        """Cargar base de conocimiento b√°sica"""
        return {
            "docker": {
                "container_fails": ["Check logs: docker-compose logs", "Restart: docker-compose restart"],
                "port_occupied": ["Find process: netstat -tulpn | grep :3000", "Kill process or change port"]
            },
            "application": {
                "db_connection": ["Check DB status: docker-compose ps", "Restart DB: docker-compose restart db"],
                "high_memory": ["Check usage: docker stats", "Restart containers"]
            }
        }
    
    def search_problems(self, query):
        """Buscar problemas por query simple"""
        results = []
        query_lower = query.lower()
        
        for category, problems in self.problems.items():
            for problem, solutions in problems.items():
                if query_lower in problem:
                    results.append({"problem": problem, "solutions": solutions})
        
        return results
    
    def generate_troubleshooting_guide(self):
        """Generar gu√≠a simple"""
        guide = "# Troubleshooting Guide\n\n"
        
        for category, problems in self.problems.items():
            guide += f"## {category.title()}\n"
            for problem, solutions in problems.items():
                guide += f"- {problem}: {solutions[0]}\n"
            guide += "\n"
        
        return guide
        
        if not user_input:
            print("‚ùå Por favor describe el problema")
            return
        
        matches = self.search_problems(user_input)
        
        if not matches:
            print("ü§î No encontr√© problemas similares en la base de datos")
            print("üí° Intenta con otros t√©rminos como:")
            print("   ‚Ä¢ 'container not starting'")
            print("   ‚Ä¢ 'connection refused'")  
            print("   ‚Ä¢ 'out of memory'")
            print("   ‚Ä¢ 'high cpu usage'")
            return
        
        print(f"\nüéØ Encontr√© {len(matches)} posible(s) soluci√≥n(es):")
        print("-" * 40)
        
        for i, match in enumerate(matches, 1):
            problem_data = match["data"]
            severity_emoji = "üî¥" if problem_data["severity"] == "high" else "üü°" if problem_data["severity"] == "medium" else "üü¢"
            
            print(f"\n{i}. {severity_emoji} {match['problem_id'].replace('_', ' ').title()}")
            print(f"   üìÇ Categor√≠a: {match['category']}")
            print(f"   üéØ Coincidencia: {match['match_text']}")
            print("   üîß Soluciones:")
            
            for j, solution in enumerate(problem_data["solutions"], 1):
                print(f"      {j}. {solution}")
        
        print(f"\nüíæ Gu√≠a completa disponible en: docs/troubleshooting-auto.md")

if __name__ == "__main__":
    kb = KnowledgeBase()
    
    # Generar gu√≠a autom√°tica
    kb.generate_troubleshooting_guide()
    print("‚úÖ Gu√≠a de troubleshooting generada")
    
    # Modo interactivo
    print("\n" + "="*50)
    kb.interactive_troubleshooting()
```

---

## üìä Paso 4: Dashboard de Documentaci√≥n (30 min)

### 4.1 Ejecutar todos los generadores
```bash
# Generar toda la documentaci√≥n
echo "üìö Generando documentaci√≥n completa..."

# 1. Documentaci√≥n general
python3 generate-docs.py

# 2. Base de conocimiento
python3 knowledge-base.py

# 3. Verificar archivos generados
echo "üìÅ Archivos generados:"
ls -la docs/

# 4. Abrir dashboard
if command -v open >/dev/null 2>&1; then
    open docs/index.html
elif command -v xdg-open >/dev/null 2>&1; then
    xdg-open docs/index.html
else
    echo "üí° Abre docs/index.html en tu navegador"
fi

echo "‚úÖ Dashboard de documentaci√≥n listo!"
```

---

## ‚úÖ Paso 5: Validar con el Equipo (15 min)

### 5.1 Checklist de validaci√≥n
```bash
#!/bin/bash
# validate-docs.sh - Validar que la documentaci√≥n sirve

echo "üìö VALIDANDO DOCUMENTACI√ìN"
echo "========================="

validation_errors=0

# 1. Verificar archivos principales
echo "üìÅ Verificando archivos de documentaci√≥n..."

required_files=(
    "README.md"
    "docs/index.html"
    "docs/deployment.md"
    "docs/troubleshooting.md"
    "docs/troubleshooting-auto.md"
    "docs/project-overview.json"
    "knowledge-base.json"
)

for file in "${required_files[@]}"; do
    if [ -f "$file" ]; then
        echo "   ‚úÖ $file"
    else
        echo "   ‚ùå $file (faltante)"
        ((validation_errors++))
    fi
done

# 2. Verificar que README tenga contenido esencial
echo "üìù Verificando contenido del README..."

if grep -q "Inicio R√°pido" README.md; then
    echo "   ‚úÖ Secci√≥n Inicio R√°pido"
else
    echo "   ‚ùå Falta secci√≥n Inicio R√°pido"
    ((validation_errors++))
fi

if grep -q "docker-compose up" README.md; then
    echo "   ‚úÖ Comandos Docker"
else
    echo "   ‚ùå Faltan comandos Docker"
    ((validation_errors++))
fi

if grep -q "Problemas Comunes" README.md; then
    echo "   ‚úÖ Secci√≥n Problemas Comunes"
else
    echo "   ‚ùå Falta secci√≥n Problemas Comunes"
    ((validation_errors++))
fi

# 3. Verificar que dashboard HTML funcione
echo "üåê Verificando dashboard HTML..."

if grep -q "Documentation" docs/index.html; then
    echo "   ‚úÖ Dashboard tiene t√≠tulo correcto"
else
    echo "   ‚ùå Dashboard mal formateado"
    ((validation_errors++))
fi

# 4. Verificar scripts de documentaci√≥n
echo "üêç Verificando scripts de documentaci√≥n..."

if python3 -c "import generate-docs; print('OK')" 2>/dev/null; then
    echo "   ‚úÖ generate-docs.py ejecutable"
else
    echo "   ‚ùå generate-docs.py tiene errores"
    ((validation_errors++))
fi

if python3 -c "import knowledge-base; print('OK')" 2>/dev/null; then
    echo "   ‚úÖ knowledge-base.py ejecutable"
else
    echo "   ‚ùå knowledge-base.py tiene errores"  
    ((validation_errors++))
fi

# 5. Test de troubleshooting interactivo
echo "üîß Testing troubleshooting interactivo..."

if echo "container not starting" | python3 knowledge-base.py > /dev/null 2>&1; then
    echo "   ‚úÖ Troubleshooting interactivo funciona"
else
    echo "   ‚ùå Troubleshooting interactivo falla"
    ((validation_errors++))
fi

# Resumen
echo
echo "üìä RESUMEN DE VALIDACI√ìN:"
echo "========================"

if [ "$validation_errors" -eq 0 ]; then
    echo "üéâ ¬°TODA LA DOCUMENTACI√ìN EST√Å LISTA!"
    echo "‚úÖ El equipo puede usar la documentaci√≥n sin problemas"
    
    echo
    echo "üîó Links importantes:"
    echo "   ‚Ä¢ Dashboard: file://$(pwd)/docs/index.html"
    echo "   ‚Ä¢ Troubleshooting: python3 knowledge-base.py"
    echo "   ‚Ä¢ Deploy: bash deploy.sh"
else
    echo "‚ö†Ô∏è  $validation_errors problemas encontrados"
    echo "üìã Corrige los errores antes de compartir con el equipo"
fi

echo
echo "üí° PR√ìXIMOS PASOS:"
echo "   1. Comparte dashboard con el equipo"
echo "   2. Entrena al equipo en troubleshooting interactivo"
echo "   3. Actualiza docs regularmente: python3 generate-docs.py"
echo "   4. Recopila feedback y mejora la documentaci√≥n"

# Generar checklist para el equipo
cat << 'EOF' > team-documentation-checklist.md
# üìö Checklist de Documentaci√≥n para el Equipo

## Para Nuevos Desarrolladores
- [ ] Leer README.md completo
- [ ] Ejecutar `bash deploy.sh` para setup inicial
- [ ] Verificar que todos los servicios funcionan
- [ ] Probar troubleshooting interactivo: `python3 knowledge-base.py`
- [ ] Bookmarkear dashboard: `docs/index.html`

## Para Uso Diario
- [ ] Usar `docs/troubleshooting.md` para problemas comunes
- [ ] Actualizar knowledge base con nuevos problemas encontrados
- [ ] Ejecutar `python3 generate-docs.py` despu√©s de cambios importantes

## Para DevOps/SRE
- [ ] Revisar m√©tricas en dashboard
- [ ] Mantener gu√≠as de deploy actualizadas
- [ ] Agregar nuevos problemas a knowledge-base.py
- [ ] Validar documentaci√≥n mensualmente: `bash validate-docs.sh`

## Feedback
- üìù Problemas con docs: crear issue con tag 'documentation'
- üí° Mejoras: sugerir en #devops-team
- üîß Nuevos problemas: ejecutar troubleshooting y agregar soluci√≥n
EOF

echo "üìã Checklist para equipo creado: team-documentation-checklist.md"
```

---

## üéØ Resultado Final

### ‚úÖ Documentaci√≥n que Realmente Se Usa:

üìù **README S√∫per Claro** - Setup en 5 minutos garantizado  
üöÄ **Gu√≠as de Deploy** - Un comando y funciona  
üîß **Troubleshooting Inteligente** - Base de conocimiento interactiva  
üìä **Dashboard Unificado** - Todo en un lugar accesible  
‚úÖ **Validaci√≥n Completa** - Confirmaci√≥n que el equipo lo puede usar  

### üöÄ Tu Equipo Ahora Tiene:

- **Onboarding de 15 minutos** en lugar de d√≠as
- **Troubleshooting autom√°tico** que resuelve problemas comunes
- **Deploy confiable** que funciona siempre
- **Documentaci√≥n viva** que se actualiza autom√°ticamente
- **Dashboard centralizado** con toda la informaci√≥n

---

## üí° Mantener la Documentaci√≥n

```bash
# Actualizar despu√©s de cambios
python3 generate-docs.py

# Agregar nuevos problemas
python3 knowledge-base.py

# Validar que todo funciona
bash validate-docs.sh
```

**üìö ¬°Tu equipo ahora tiene documentaci√≥n que realmente usan porque es √∫til y f√°cil!**

*La mejor documentaci√≥n es la que resuelve problemas reales del d√≠a a d√≠a.* üìñ‚ú®
